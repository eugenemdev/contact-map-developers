{"version":3,"sources":["components/Services/Grammar.js","components/Services/Models/Token.js","components/Services/Config.js","components/Services/Service.js","components/Services/Parser/Lexer.js","components/Services/Parser/Parser.js","components/SearchControl/SearchControlList.js","components/SearchControl/SearchControl.js","components/Utils/Utilits.js","components/ContactMap/Contactmap.js","components/App/App.js","index.js"],"names":["Grammar","tokens","patterns","Token","this","token","type","value","id","position","start","line","column","end","feature","Config","host","dataType","instance","Service","CONFIG","data","persons","getCall","a","fetch","method","headers","Accept","catch","error","console","log","response","json","text","Lexer","stream","getData","grammar","features","forEach","createToken","checkTokens","properties","description","str","key","array","findMatches","setType","setValue","setPositionStartLine","setPositionStartColumn","String","length","setPositionEndLine","setPositionEndColumn","setId","setFeature","push","pattern","match","Parser","getStream","sortedStream","prepare","list","mapped","map","el","i","index","sort","b","getValue","result","word","patternWord","toLowerCase","isNaN","getType","uniq","getId","filter","item","pos","ary","SearchControlList","props","clickListItem","parser","event","searchedList","li","document","querySelectorAll","liSection","updateList","getAttribute","remove","state","keys","activelist","showList","search","setState","sectionList","getElementsByClassName","firstChild","removeChild","createElement","className","setAttribute","innerHTML","getFeature","img","username","city","addEventListener","e","target","matches","appendChild","Component","SearchControl","pressKeyInput","isCloseButtonVisible","isWrapperList","keyCode","inputValue","updateInfo","newPersons","isSearchVisible","clickOpenSearchButton","bind","clickCloseButton","closeSearch","onClick","viewBox","x1","y1","x2","y2","cx","cy","r","fill","placeholder","onKeyDown","onChange","d","Utils","element","func","attachEvent","ContactMap","boundariesColor","color","center","latLngGeom","boundaries","geometry","group","mapRef","useRef","useEffect","osm","L","TileLayer","boundaryCanvas","boundary","attribution","current","zoom","layers","minZoom","maxZoom","zoomSnap","activeIcon","icon","iconUrl","iconSize","iconAnchor","ActivePeoples","geoJson","pointToLayer","latlng","marker","bindPopup","Subscribe","openPopup","boundariesLayer","geoJSON","style","clusters","markerClusterGroup","spiderfyOnMaxZoom","showCoverageOnHover","zoomToBoundsOnClick","chunkedLoading","removeLayer","addLayer","flyTo","coordinates","markersGroup","featureGroup","fitBounds","getBounds","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.3591bedb.chunk.js","sourcesContent":["/**\n    Grammar is descriptions about tokens\n    @return patterns for search tokens and making tokens stream\n */\n\nconst Grammar = {    \n            tokens : {                \n                patterns: {\n                    \"javascript\": /[j|J](ava|)[s|S](cript|)/g,\n                    \"java\" : /[j|J](ava|AVA)(\\s)/g,\n                    \"c++\" : /[c|C](\\++|\\+|plus)/g,\n                    \"python\" : /[p|P](i|y|I|Y)(ton|thon|TON|THON)/g,\n                    \"php\" : /[p|P](h|H)(P|p)/g,\n                    \"swift\" : /[s|S](wift|WIFT)/g,\n                    \"android\" : /[a|A](ndroid|droid|NDROID|ndroid|nroid|NROID)/g,\n                    \"ios\" : /[i|I](OS|os|0s)/g,\n                    \"bash\" : /[b|B](ash|ASH)/g,\n                    \"text@\" : /[a-zA-Z0-9_\\-\\+\\.\\:\\,\\!]+[\\w\\-\\+\\.\\:\\,\\!]/g                \n                }\n            }   \n        }\n\nexport default Grammar;","const Token = class Token {\n\n    constructor() {\n        this.token = {\n            type: \"\",\n            value: \"\",\n            id: \"\",\n            position: {\n                start: {\n                    line: \"\",\n                    column: \"\"\n                },\n                end: {\n                    line: \"\",\n                    column: \"\"\n                }\n            },            \n            feature: {}\n        }\n    }\n\n    setType(type) {\n        this.token.type = type;\n    }\n\n    getType() {\n        return this.token.type;\n    }\n\n    setValue(value) {\n        this.token.value = value;\n    }\n\n    getValue() {\n        return this.token.value\n    }\n\n    setId(id) {\n        this.token.id = id;\n    }\n\n    getId() {\n        return this.token.id\n    }\n\n    setPositionStartLine(line) {\n        this.token.position.start.line = line;\n    }\n\n    getPositionStartLine() {\n        return this.token.position.start.line\n    }\n\n    setPositionStartColumn(column) {\n        this.token.position.start.column = column;\n    }\n\n    getPositionStartColumn() {\n        return this.token.position.start.column;\n    }\n\n    setPositionEndLine(line) {\n        this.token.position.end.line = line;\n    }\n\n    getPositionEndLine() {\n        return this.token.position.end.line\n    }\n\n    setPositionEndColumn(column) {\n        this.token.position.end.column = column;\n    }\n\n    getPositionEndColumn() {\n        return this.token.position.end.column;\n    }\n\n    setFeature(feature){\n        this.token.feature = feature;\n    }\n\n    getFeature(){\n        return this.token.feature;\n    }\n\n}\n\nexport default Token;","/**\n * @param host you can use 'http://192.168.0.1/data'\n * @param dataType by default is 'json', can use 'text'\n * @param instance by default data about persons in  file persons.json\n */\n\nconst Config = {\n    host: '',\n    dataType: 'json',\n    instance: '../../data/persons.json'\n}\n\nexport default Config;","'use strict'\n//import { useHistory } from 'react-router-dom';\nimport CONFIG from './Config'\nimport persons from '../../data/persons.json'\n\n/**\n *\n * @async GET call to the server \n * @param {string: 'json' || 'text'} dataType  \n * @param {string: name of host} host \n * @return {data in format json or text} \n * @return {callback} - for 404 page with Usehistory from React\n */\n\nexport default class Service {\n  \n  constructor(){\n    this.dataType = CONFIG.dataType;\n    this.host = CONFIG.host != '' ? CONFIG.host : null;  \n    this.data = {}; \n  }\n\n  getData(){\n    if(this.host == null){\n      this.data = {data: persons};\n    }else{\n      this.data = this.getCall();\n    }\n\n    return this.data.data\n  }\n\n  async getCall() {\n      const response = await fetch(\n        this.host, {\n        method: 'GET',\n        headers: { \n          'Content-Type': 'application/json',\n          Accept: 'application/json'\n        }\n      })\n        .catch((error) => {\n          console.log(error)          \n          /**\n           * need to correct for your environment \n           */\n          //const history = useHistory()\n          //history.push('/error404') \n        })\n      \n      this.data = (this.dataType === 'json' ? await response.json() : await response.text())\n    \n    return this.data.data\n  }\n\n}\n","import grammar from '../Grammar'\nimport Token from '../Models/Token'\nimport Service from '../Service'\n\n/**\n * Lexer's concept is:\n *   - token stream\n *   - token\n *   - lexical scoping\n *   - lexical context\n *   \n *   @param json file with information about developers\n *   @param Grammar.js with description of tokens      \n *   @return token stream\n *   \n *   @example:\n *       {\n *           type: 'text',\n *           value: 'this is the test',\n *           id: 12,\n *           position : {\n *              start: {\n *                  line: 0,\n *                  column: 1\n *              },\n *              end: {\n *                  line: 0,\n *                  column: 3\n *              }  \n *           },\n *           \"geometry\": {\n *              \"type\": \"Point\",\n *              \"coordinates\": [ \"7.705953\", \"52.358919\"]\n *            }   \n *        }\n *\n */\n\nconst Lexer =  class Lexer {\n\n    constructor(){\n        \n        this.stream = [];\n        this.data = new Service().getData();\n        //console.log(this.data)\n\n    }\n    \n    getStream(){\n\n        var patterns = grammar.tokens.patterns;\n\n        this.data.features.forEach(feature => {                    \n            \n            this.createToken(feature, 'username');\n            this.createToken(feature, 'city');\n            this.createToken(feature, 'state');\n            \n            /**\n             *  @TODO if we have other options\n                this.createToken(feature, 'company');\n                this.createToken(feature, 'age');        \n             */\n            \n                 \n            this.checkTokens(feature.properties.description, feature);\n            \n            /**\n             * @TODO if we have other options and need to see by regex expression\n             * this.checkTokens(feature.properties.address, feature);        \n             */\n            \n        })  \n\n        return this.stream\n    }\n\n    checkTokens(str, feature){\n\n        var patterns = grammar.tokens.patterns;\n        var line = 0;\n        var column = 0;\n\n        for(var key in patterns){      \n\n            const array = this.findMatches(str, patterns[key]);           \n            if(array!=null){\n                array.forEach(value => {\n                    \n                    var token = new Token();\n                    token.setType(key);\n                    token.setValue(value);\n                    token.setPositionStartLine(line);\n                    token.setPositionStartColumn(column);\n                    column = String(value).length;\n                    token.setPositionEndLine(line);\n                    token.setPositionEndColumn(column);\n                    token.setId(feature.id);\n                    token.setFeature(feature);\n                    this.stream.push(token);           \n\n                })\n            }\n            \n        }\n\n    }\n\n    createToken(feature, type){\n        \n        var line = 0;\n        var column = String(feature.properties[type]).length;\n        var token = new Token();\n\n        token.setType(type);\n        token.setValue(feature.properties[type]);\n        token.setPositionStartLine(line);\n        token.setPositionStartColumn(0);            \n        token.setPositionEndLine(line);\n        token.setPositionEndColumn(column);\n        token.setId(feature.id);\n        token.setFeature(feature);                     \n        \n        this.stream.push(token);           \n    }\n     \n    findMatches(str, pattern){ \n        return str.match(pattern)\n    }\n\n\n}\n\nexport default Lexer;","import Lexer from './Lexer'\n\n/**\n *  Syntax Tree is possible, but for first realisaton and quick search we need \n *  to use 'map' and function 'sort()' for abc-sorting \n *\n *  it will be in the future:\n *  Parses a stream of tokens into an Abstract Syntax Tree (AST)\n *  Concept: Absract Syntax Tree (AST), nodes , dynamic scoping, dynamic context\n *  Target: By nodes we can search more quickly and effecient. Nodes we can show as\n *          some filters in our html template\n *  \n *   {\n *      type: 'root',\n *      nodes: [\n *          {\n *          type: 'text',\n *          value: 'abc',\n *          position: {start: {column: 1 line: 1}, end: {column: 3, line: 1}}\n *          },\n *          {\n *          type: 'text',\n *          value: 'fde',\n *          position: {start: {column: 4 line: 1}, end: {column: 8, line: 1}}\n *          }, \n *          ...\n *      ]\n *   }\n * \n * \n */\n\nexport default class Parser {\n    constructor() {\n        this.stream = new Lexer().getStream();\n        this.sortedStream = [];\n        \n        //prepare stream to quick search\n        this.prepare();\n    }\n\n    /**\n     * @param {no}\n     * @returns sorted stream for next using by searching of some value\n     * this method isn't actuall if we havn't  hierarchial searching\n     * @TODO need make hierarchial searching by word \n     */\n\n    prepare(){\n        // temp array consists of objects with position and sorting's value\n        var list = this.stream\n        var mapped = list.map(function (el, i) {\n            return {\n                index: i,\n                token: el\n            };\n        });\n\n        //sorting array\n        mapped.sort(function (a, b) {\n            if (a.token.getValue() > b.token.getValue()) {\n                return 1;\n            }\n            if (a.token.getValue() < b.token.getValue()) {\n                return -1;\n            }\n            return 0;\n        });\n\n        //result container\n        var result = mapped.map(function (token) {\n            return list[token.index];\n        });\n        this.sortedStream = result;        \n        return result\n    }\n\n    /**\n     * \n     * @param {searched value from input search, typed in the browser} word \n     * @returns {array of tokens, which have token.value like @param:word}\n     */\n    search(word) {\n        var list = this.sortedStream;\n        var result = []     \n        var patternWord = word.toLowerCase();\n\n        if (word.length >= 1) {\n            list.map(function (token) {\n                //number returns already undefined\n                // it will be checked as string or number\n                if (isNaN(token.getValue())) {\n\n                    var value = token.getValue();\n                    var type = token.getType();\n\n                    //if (value.toLowerCase() == patternWord || type == patternWord) {\n                    if ((value.toLowerCase()).match(patternWord)  || type==patternWord ) {\n                        result.push(token);\n                    }\n                } else {\n                    //if (token.getValue() == patternWord) {\n                    if ((token.getValue()).match(patternWord)) {\n                        result.push(token);\n                    }\n                }\n            })            \n            //remove double values and return \n            return this.uniq(result);\n        }\n        //if result []\n        return result;\n    }\n\n    /**\n     * @param {array with doubled tokens} a\n     * @returns {array without unidue values}  \n     */\n    uniq(a) {\n        return a.sort(function (a, b) {                                \n            if (a.getId() > b.getId()) {\n                return 1;\n            }\n            if (a.getId() < b.getId()) {\n                return -1;\n            }\n            return 0;                \n        }).filter(function(item, pos, ary) {\n            return !pos || item.getId() != ary[pos - 1].getId();\n        });\n    }\n\n}","import React, { Component }  from 'react';\nimport Parser from '../Services/Parser/Parser'\n\n\nexport default class SearchControlList extends Component {\n    \n    \n    constructor(props) {\n        super(props);     \n        this.state = {\n            keys: \"\",\n            activelist: \"closed\"\n        };\n\n        this.parser = new Parser();\n        this.searchedList = []\n\n\n    }\n\n    componentDidUpdate(){\n        if(this.state.activelist != this.props.activelist){\n            this.showList();\n        }\n        \n        this.search(this.props.keys);\n    }\n\n    showList(){\n        this.setState({\n            activelist: this.props.activelist\n          });          \n    }\n\n    clickListItem = ( props, parser, token ) => ( event ) => {        \n        var searchedList = [];\n        const li = document.querySelectorAll('li[choosed]');\n        const liSection = document.querySelectorAll('li[key]');\n        if(li[0]){            \n            searchedList.push(token);\n            props.updateList(searchedList);\n            \n            for(var i=0; i < liSection.length; i++){\n                if(liSection[i].getAttribute('choosed')==null){\n                    liSection[i].remove();\n                }\n            }\n\n        }\n    }\n\n    search(word){        \n        this.searchedList = this.parser.search(word);\n        \n        if(this.searchedList[0]){\n            \n            //send list to props of the parent component \n            this.props.updateList(this.searchedList);\n\n            const sectionList = document.getElementsByClassName('search-control-info-list');\n            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n            \n              //console.log(searchedList)\n\n              this.searchedList.forEach(token =>{\n                var li = document.createElement('li');\n                li.className = 'search-control-info-list-item' \n                li.setAttribute('key', token.getId())     \n                li.innerHTML= `\n                    <span-left>\n                        <img src=\"${token.getFeature().properties.img}\"/>\n                        <h3>${token.getFeature().properties.username}</h3>\n                        <h3>${token.getFeature().properties.city}</h3>                    \n                    </span-left>\n                    <span-right>\n                        <p>Skills: ${token.getFeature().properties.description}</p>                \n                    </span-right> `\n\n                li.addEventListener(\"click\", this.clickListItem(this.props, this.parser, token));\n                li.addEventListener(\"click\", function(e){\n                    if (e.target && e.target.matches(\"li.search-control-info-list-item\")) {\n                        e.target.setAttribute(\"choosed\", \"true\"); // new attribute                        \n                      }\n                });\n\n                sectionList[0].appendChild(li);\n            })\n            \n        }\n    }\n\n\nrender() {\n\n    return (\n        <ul className=\"search-control-info-list\">                         \n        </ul>\n    );\n    }\n}\n","import React, {Component, useState} from 'react';\nimport SearchControlList from './SearchControlList'\nimport './search-control.css'\n\n\nexport default class SearchControl extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            isSearchVisible: false,\n            isCloseButtonVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: \"\"\n        };\n\n\n        //bind for callbacks\n        this.clickOpenSearchButton = this.clickOpenSearchButton.bind(this);\n        this.clickCloseButton = this.clickCloseButton.bind(this);\n        this.pressKeyInput = this.pressKeyInput.bind(this); \n        \n    }\n\n    clickOpenSearchButton() {\n        this.setState(state => ({\n            isSearchVisible: !state.isSearchVisible,\n            isWrapperList: \"closed\",\n            inputValue: \"\"        \n        }));\n\n        //send close to high component for update map view\n        this.props.closeSearch('closed');\n        //remove all children from search list\n        const sectionList = document.getElementsByClassName('search-control-info-list');            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n    }\n\n\n    clickCloseButton() {\n        this.setState(state => ({\n            isCloseButtonVisible: !state.isCloseButtonVisible,\n            isSearchVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: ''\n        }));\n\n        //send close to high component for update map view\n        this.props.closeSearch('closed');\n        \n        //remove all children from search list\n        const sectionList = document.getElementsByClassName('search-control-info-list');            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n    }\n\n    \n    pressKeyInput = (props, document) =>(e) => {\n        \n        //visible close button \n        this.setState(state => ({\n            isCloseButtonVisible: true,\n            isWrapperList: \"opened\"\n        }));\n                \n        //var nodes = document.getElementsByClassName(\"search-control-info-list-item\");\n\n        if (e.keyCode == 40) { \n            //TODO \n            console.log('key DOWN')\n        } else if (e.keyCode == 38) { \n            //TODO \n            console.log('key UP')\n        } else if (e.keyCode == 13) {\n            //TODO \n            console.log('key ENTER')\n        } else if(e.keyCode == 8) {\n                    \n            console.log('key BACKSPACE')\n            \n            \n            if(this.state.inputValue.length == 0){                \n                //remove all markers\n                props.updateInfo([]);\n                //remove all DOM elements form list\n                const sectionList = document.getElementsByClassName('search-control-info-list');                            \n                while (sectionList[0].firstChild) {\n                    sectionList[0].removeChild(sectionList[0].firstChild);\n                }\n\n            }            \n            \n        }\n        \n        \n    }\n\n\n    //it's call from SearchControlList to this parent component\n    updateList = (list) => {\n        \n        const newPersons = { \"type\": \"FeatureCollection\", \"features\": [] }  \n        list.forEach(token =>{\n            newPersons.features.push(token.getFeature())\n        })\n        \n        this.props.updateInfo(newPersons);\n\n\n    }\n\n    render() {\n      return (\n      <div className=\"search-box\">\n        <article className=\"search-control-wrap\">  \n            <section className={this.state.isSearchVisible?\"search-control search-control-active\":\"search-control\"}>\n                <button className=\"search-control-icon-button\" \n                    onClick={this.clickOpenSearchButton}>                \n                    <svg viewBox=\"0 0 50 50\">\n                        <line x1=\"35\" y1=\"35\" x2=\"46\" y2=\"46\"/>\n                        <circle cx=\"23\" cy=\"23\" r=\"16\" fill=\"none\"></circle> \n                            Sorry, your browser does not support inline SVG.\n                    </svg>                    \n                </button>                \n                <input \n                    type=\"text\" \n                    className=\"search-input search-control-input\" \n                    placeholder=\"custom placeholder\" \n                    onKeyDown={this.pressKeyInput(this.props, document)}\n                    onChange={e => this.setState({ inputValue: e.target.value })} \n                    value={this.state.inputValue}/>                \n                <button className={ this.state.isCloseButtonVisible ? \"search-control-close-button search-control-close-button-active\": \"search-control-close-button\"} onClick={this.clickCloseButton}>\n                    <svg viewBox=\"0 0 50 50\">\n                        <path d=\"M5 5 L45 45 M45 5 L5 45\"/>\n                        Sorry, your browser does not support inline SVG.\n                    </svg>\n                </button>\n            </section>\n            <section className={this.state.isWrapperList==\"opened\"?\"search-control-info-wrapper\":\"search-control-info-wrapper search-control-info-wrapper-close\"} >\n                <section className=\"search-control-info\">            \n                    <SearchControlList \n\n                        activelist={this.state.isWrapperList} \n                        keys={this.state.inputValue}\n                        updateList = {this.updateList}\n                    />\n                </section>            \n            </section>    \n        </article>\n     </div>\n      );\n    }\n  }\n","'use strict'\n\nexport default class Utils {\n\n    constructor () {     \n        this.document = document\n    }\n\n    Subscribe(event, element, func) {\n        if (element.addEventListener) {\n            element.addEventListener(event, func, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, func);\n        } else {\n            element['on' + event] = func;\n        }\n      }\n    \n\n}\n\n\n","import React, { useEffect, useRef, useState} from 'react';\nimport L from 'leaflet';\nimport 'leaflet.markercluster'\nimport SearchControl from '../SearchControl/SearchControl';\nimport 'leaflet-boundary-canvas';\nimport Utils from '../Utils/Utilits';\nimport boundaries from \"../../data/boundaries.json\";\nimport persons from \"../../data/persons.json\";\nimport './ContactMap.css'\n\n\nexport default function ContactMap(props) {\n\n  /**\n  * set new map and add boundared layer\n  */\n const boundariesColor = {\n    color: \"orange\",\n    fill: false \n  };\n\n\n  const center = [51.0, 10.917];\n  const zoom = 6;\n  const minZoom = 4;\n  const maxZoom = 9;\n  const zoomSnap = 0.25\n  const latLngGeom = boundaries.geometry; //Define real geometry here\n  const osmUrl = 'https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png';\n  const osmAttribution = '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\n  var group = [];\n  const mapRef = useRef(null)\n\n\n  useEffect(() => {\n\n    var osm = L.TileLayer.boundaryCanvas(osmUrl, {\n      boundary: latLngGeom,\n        attribution: osmAttribution\n    })\n    \n    mapRef.current = L.map('map', {\n        center: center,\n        zoom: zoom,\n        layers: osm,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomSnap: zoomSnap\n    })\n        \n  }, [center, zoom, minZoom, maxZoom, zoomSnap])\n\n  /**\n   *  Set markers and position \n   */\n  \n  //set new icon image for markers\n  const activeIcon = L.icon({\n    iconUrl: './img/marker-icon.png',\n    iconSize: [25, 41],\n    iconAnchor: [12,41]\n  });\n\n\n  var ActivePeoples = L.geoJson(persons, {\n    pointToLayer: function (feature, latlng) {\n      \n      var marker = L.marker(latlng, {\n        icon: activeIcon\n      });\n\n      marker.bindPopup(\n        '<div class=\"popups-widget-top\">'+\n          '<img src=\"'+feature.properties.img+'\" alt=\"avatar\"/>'+\n            '<div class=\"popups-top-right-section\">'+\n            '<p> '+feature.properties.username + '</p>'+\n            '<p> from '+feature.properties.city+'</p>' +       \n            '</div>'+\n         '</div>'+\n         '<div class=\"popups-widget-bottom\">'+\n            ' Skills: ' + feature.properties.description +\n         '</div>'\n\n      );\n\n      //marker.openPopup() doesnt work in Safari\n      //this is some hook             \n      function func() {\n        marker.openPopup();\n      }        \n\n      //for making right position to fit all markers to the map\n      group.push(marker);\n\n\n      var utils = new Utils();\n      utils.Subscribe('click', marker, func);        \n      return marker;\n    }\n\n  });\n\n\n  const boundariesLayer = L.geoJSON(boundaries, {\n    style: function (feature) {\n      return boundariesColor;\n    }\n  });\n\n\n  var clusters = L.markerClusterGroup({\n      spiderfyOnMaxZoom: true,\n\t    showCoverageOnHover: true,\n\t    zoomToBoundsOnClick: true,\n      chunkedLoading: true\n    });    \n    \n    clusters.addLayer(boundariesLayer);\n    clusters.addLayer(ActivePeoples);\n\n  useEffect(() => {\n    \n    mapRef.current.addLayer(clusters)           \n\n    //we fly to all clusters and set zoom to fit\n    var markersGroup = new L.featureGroup(group);\n    mapRef.current.fitBounds(markersGroup.getBounds())\n\n\n  }, [clusters])\n\n\n\n/**\n * this is callback from SearchControlList component\n * @param list  returns the list of tokens to updating of our markers\n * @return new person.json object \n */\nfunction updateInfo(data){\n\n\n  clusters.removeLayer(ActivePeoples);\n\n  ActivePeoples = L.geoJson(data, {\n    pointToLayer: function (feature, latlng) {      \n      var marker = L.marker(latlng, { icon: activeIcon});\n      marker.bindPopup(\n        '<div class=\"popups-widget-top\">'+\n          '<img src=\"'+feature.properties.img+'\" alt=\"avatar\"/>'+\n            '<div class=\"popups-top-right-section\">'+\n            '<p> '+feature.properties.username + '</p>'+\n            '<p> from '+feature.properties.city+'</p>' +       \n            '</div>'+\n         '</div>'+\n         '<div class=\"popups-widget-bottom\">'+\n            ' Skills: ' + feature.properties.description +\n         '</div>'\n      );\n      //marker.openPopup() doesnt work in Safari\n      //this is some hook             \n      function func() {\n        marker.openPopup();\n      }        \n      \n      //for making right position to fit all markers to the map\n      group.push(marker);\n\n      var utils = new Utils();\n      utils.Subscribe('click', marker, func);        \n      return marker;\n\n    }\n\n  });\n\n  clusters.addLayer(ActivePeoples);\n\n\n  /**\n     * if we have 1 person to view \n     * we fly to this person and see the map with maxZoom\n     */\n\n  if( data.features && data.features.length == 1){\n    //console.log(data.features[0].geometry.coordinates)\n    mapRef.current.flyTo([\n      data.features[0].geometry.coordinates[1],\n      data.features[0].geometry.coordinates[0]], \n      maxZoom)\n  } else {\n\n  //we fly to all clusters and set zoom to fit\n  var markersGroup = new L.featureGroup(group);\n  mapRef.current.fitBounds(markersGroup.getBounds())\n  }\n}\n\n//props callback\n function closeSearch(event){\n   if(event == 'closed'){    \n      updateInfo(persons);\n   }\n }\n\nreturn <div>\n          <SearchControl updateInfo={updateInfo} closeSearch={closeSearch}/>\n          <div id='map'></div>\n        </div>\n\n}","import React, { Component } from 'react';\nimport \"./App.css\";\nimport ContactMap from '../ContactMap/Contactmap';\n\n \nclass App extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div>\n        <ContactMap/>\n      </div>\n    );\n  }\n}\n \nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}