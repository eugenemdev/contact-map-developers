{"version":3,"sources":["components/Services/Grammar.js","components/Services/Token.js","components/Services/Lexer.js","components/Services/Parser.js","components/SearchControl/SearchControlList.js","components/SearchControl/SearchControl.js","components/Utils/Utilits.js","components/ContactMap/Contactmap.js","components/App/App.js","index.js"],"names":["Grammar","tokens","patterns","Token","this","token","type","value","id","position","start","line","column","end","feature","Lexer","stream","data","persons","grammar","features","forEach","createToken","checkTokens","properties","description","str","key","array","findMatches","setType","setValue","setPositionStartLine","setPositionStartColumn","String","length","setPositionEndLine","setPositionEndColumn","setId","setFeature","push","pattern","match","Parser","getStream","sortedStream","prepare","list","mapped","map","el","i","index","sort","a","b","getValue","result","word","patternWord","toLowerCase","isNaN","getType","uniq","getId","filter","item","pos","ary","SearchControlList","props","clickListItem","parser","event","searchedList","li","document","querySelectorAll","liSection","updateList","getAttribute","remove","state","keys","activelist","showList","search","setState","sectionList","getElementsByClassName","firstChild","removeChild","createElement","className","setAttribute","innerHTML","getFeature","username","city","addEventListener","e","target","matches","appendChild","Component","SearchControl","newPersons","updateInfo","isSearchVisible","isCloseButtonVisible","isWrapperList","inputValue","clickOpenSearchButton","bind","clickCloseButton","pressKeyInput","closeSearch","onClick","viewBox","x1","y1","x2","y2","cx","cy","r","fill","placeholder","onKeyDown","onChange","d","Utils","element","func","attachEvent","ContactMap","boundariesColor","color","center","latLngGeom","boundaries","geometry","mapRef","useRef","useEffect","osm","L","TileLayer","boundaryCanvas","boundary","attribution","current","zoom","layers","activeIcon","icon","iconUrl","iconSize","iconAnchor","ActivePeoples","geoJson","pointToLayer","latlng","marker","bindPopup","Subscribe","openPopup","boundariesLayer","geoJSON","style","clusters","markerClusterGroup","removeLayer","addLayer","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.bac86d94.chunk.js","sourcesContent":["/**\n    Grammar is descriptions about tokens\n    @return patterns for search tokens and making tokens stream\n */\n\nconst Grammar = {    \n            tokens : {                \n                patterns: {\n                    \"javascript\": /[j|J](ava|)[s|S](cript|)/g,\n                    \"java\" : /[j|J](ava|AVA)(\\s)/g,\n                    \"c++\" : /[c|C](\\++|\\+|plus)/g,\n                    \"python\" : /[p|P](i|y|I|Y)(ton|thon|TON|THON)/g,\n                    \"php\" : /[p|P](h|H)(P|p)/g,\n                    \"swift\" : /[s|S](wift|WIFT)/g,\n                    \"android\" : /[a|A](ndroid|droid|NDROID|ndroid|nroid|NROID)/g,\n                    \"ios\" : /[i|I](OS|os|0s)/g,\n                    \"bash\" : /[b|B](ash|ASH)/g,\n                    \"text@\" : /[a-zA-Z0-9_\\-\\+\\.\\:\\,\\!]+[\\w\\-\\+\\.\\:\\,\\!]/g                \n                }\n            }   \n        }\n\nexport default Grammar;","const Token = class Token {\n\n    constructor() {\n        this.token = {\n            type: \"\",\n            value: \"\",\n            id: \"\",\n            position: {\n                start: {\n                    line: \"\",\n                    column: \"\"\n                },\n                end: {\n                    line: \"\",\n                    column: \"\"\n                }\n            },            \n            feature: {}\n        }\n    }\n\n    setType(type) {\n        this.token.type = type;\n    }\n\n    getType() {\n        return this.token.type;\n    }\n\n    setValue(value) {\n        this.token.value = value;\n    }\n\n    getValue() {\n        return this.token.value\n    }\n\n    setId(id) {\n        this.token.id = id;\n    }\n\n    getId() {\n        return this.token.id\n    }\n\n    setPositionStartLine(line) {\n        this.token.position.start.line = line;\n    }\n\n    getPositionStartLine() {\n        return this.token.position.start.line\n    }\n\n    setPositionStartColumn(column) {\n        this.token.position.start.column = column;\n    }\n\n    getPositionStartColumn() {\n        return this.token.position.start.column;\n    }\n\n    setPositionEndLine(line) {\n        this.token.position.end.line = line;\n    }\n\n    getPositionEndLine() {\n        return this.token.position.end.line\n    }\n\n    setPositionEndColumn(column) {\n        this.token.position.end.column = column;\n    }\n\n    getPositionEndColumn() {\n        return this.token.position.end.column;\n    }\n\n    setFeature(feature){\n        this.token.feature = feature;\n    }\n\n    getFeature(){\n        return this.token.feature;\n    }\n\n}\n\nexport default Token;","import persons from '../../data/persons.json';\nimport grammar from './Grammar'\nimport Token from './Token'\n\n/**\n * Lexer's concept is:\n *   - token stream\n *   - token\n *   - lexical scoping\n *   - lexical context\n *   \n *   @param json file with information about developers\n *   @param Grammar.js with description of tokens      \n *   @return token stream\n *   \n *   @example:\n *       {\n *           type: 'text',\n *           value: 'this is the test',\n *           id: 12,\n *           position : {\n *              start: {\n *                  line: 0,\n *                  column: 1\n *              },\n *              end: {\n *                  line: 0,\n *                  column: 3\n *              }  \n *           },\n *           \"geometry\": {\n *              \"type\": \"Point\",\n *              \"coordinates\": [ \"7.705953\", \"52.358919\"]\n *            }   \n *        }\n *\n */\n\nconst Lexer =  class Lexer {\n\n    constructor(){\n        \n        this.stream = [];\n        this.data = persons;\n\n    }\n    \n    getStream(){\n\n        var patterns = grammar.tokens.patterns;\n\n        this.data.features.forEach(feature => {                    \n            \n            this.createToken(feature, 'username');\n            this.createToken(feature, 'city');\n            this.createToken(feature, 'state');\n            \n            //TODO: if we have other options\n            //this.createToken(feature, 'company');\n            //this.createToken(feature, 'age');       \n                 \n            this.checkTokens(feature.properties.description, feature);\n            \n            //TODO: if we have other options and need to see by regex expression\n            //this.checkTokens(feature.properties.address, feature);        \n            \n        })  \n\n        return this.stream\n    }\n\n    checkTokens(str, feature){\n\n        var patterns = grammar.tokens.patterns;\n        var line = 0;\n        var column = 0;\n\n        for(var key in patterns){      \n\n            const array = this.findMatches(str, patterns[key]);           \n            if(array!=null){\n                array.forEach(value => {\n                    \n                    var token = new Token();\n                    token.setType(key);\n                    token.setValue(value);\n                    token.setPositionStartLine(line);\n                    token.setPositionStartColumn(column);\n                    column = String(value).length;\n                    token.setPositionEndLine(line);\n                    token.setPositionEndColumn(column);\n                    token.setId(feature.id);\n                    token.setFeature(feature);\n                    this.stream.push(token);           \n\n                })\n            }\n            \n        }\n\n    }\n\n    createToken(feature, type){\n        \n        var line = 0;\n        var column = String(feature.properties[type]).length;\n        var token = new Token();\n\n        token.setType(type);\n        token.setValue(feature.properties[type]);\n        token.setPositionStartLine(line);\n        token.setPositionStartColumn(0);            \n        token.setPositionEndLine(line);\n        token.setPositionEndColumn(column);\n        token.setId(feature.id);\n        token.setFeature(feature);                     \n        \n        this.stream.push(token);           \n    }\n     \n    findMatches(str, pattern){ \n        return str.match(pattern)\n    }\n\n\n}\n\nexport default Lexer;","import Lexer from './Lexer'\n\n/**\n *  Syntax Tree is possible, but for first realisaton and quick search we need \n *  to use 'map' and function 'sort()' for abc-sorting \n *\n *  it will be in the future:\n *  Parses a stream of tokens into an Abstract Syntax Tree (AST)\n *  Concept: Absract Syntax Tree (AST), nodes , dynamic scoping, dynamic context\n *  Target: By nodes we can search more quickly and effecient. Nodes we can show as\n *          some filters in our html template\n *  \n *   {\n *      type: 'root',\n *      nodes: [\n *          {\n *          type: 'text',\n *          value: 'abc',\n *          position: {start: {column: 1 line: 1}, end: {column: 3, line: 1}}\n *          },\n *          {\n *          type: 'text',\n *          value: 'fde',\n *          position: {start: {column: 4 line: 1}, end: {column: 8, line: 1}}\n *          }, \n *          ...\n *      ]\n *   }\n * \n * \n */\n\nexport default class Parser {\n    constructor() {\n        this.stream = new Lexer().getStream();\n        this.sortedStream = [];\n        //make searched map\n        this.prepare();\n    }\n\n\n    prepare(){\n        // temp array consists of objects with position and sorting's value\n        var list = this.stream\n        var mapped = list.map(function (el, i) {\n            return {\n                index: i,\n                token: el\n            };\n        });\n\n        //sorting array\n        mapped.sort(function (a, b) {\n            if (a.token.getValue() > b.token.getValue()) {\n                return 1;\n            }\n            if (a.token.getValue() < b.token.getValue()) {\n                return -1;\n            }\n            return 0;\n        });\n\n        //result container\n        var result = mapped.map(function (token) {\n            return list[token.index];\n        });\n\n        this.sortedStream = result;\n        \n        return result\n    }\n\n    search(word) {\n        var list = this.sortedStream;\n        var result = []\n        var patternWord = word.toLowerCase();\n        //var pattern = \"/\" + patternWord + \"/\"\n\n        if (word.length >= 2) {\n\n            list.map(function (token) {\n\n                //number returns already undefined\n                // it will be checked as string or number\n                if (isNaN(token.getValue())) {\n\n                    var value = token.getValue();\n                    var type = token.getType();\n\n                    if (value.toLowerCase() == patternWord || type == patternWord) {\n\n                        result.push(token);\n\n                    }\n\n                } else {\n\n                    if (token.getValue() == patternWord) {\n\n                        result.push(token);\n\n                    }\n                }\n            })\n            \n\n            //remove double values and return \n            return this.uniq(result);\n        }\n\n        //if result []\n        return result;\n    }\n\n    findMatches(str, pattern) {\n        return str.match(pattern)\n    }\n\n    uniq(a) {\n        return a.sort(function (a, b) {                                \n            if (a.getId() > b.getId()) {\n                return 1;\n            }\n            if (a.getId() < b.getId()) {\n                return -1;\n            }\n            return 0;                \n        }).filter(function(item, pos, ary) {\n            //console.log(item.getId())\n            return !pos || item.getId() != ary[pos - 1].getId();\n        });\n    }\n\n}","import React, { Component }  from 'react';\nimport Parser from '../Services/Parser'\n\n\nexport default class SearchControlList extends Component {\n    \n    \n    constructor(props) {\n        super(props);     \n        this.state = {\n            keys: \"\",\n            activelist: \"closed\"\n        };\n\n        this.parser = new Parser();\n        this.searchedList = []\n\n\n    }\n\n    componentDidUpdate(){\n        if(this.state.activelist != this.props.activelist){\n            this.showList();\n        }\n        \n        this.search(this.props.keys);\n    }\n\n    showList(){\n        this.setState({\n            activelist: this.props.activelist\n          });          \n    }\n\n    clickListItem = ( props, parser, token ) => ( event ) => {        \n        var searchedList = [];\n        const li = document.querySelectorAll('li[choosed]');\n        const liSection = document.querySelectorAll('li[key]');\n        if(li[0]){            \n            searchedList.push(token);\n            props.updateList(searchedList);\n            \n            for(var i=0; i < liSection.length; i++){\n                if(liSection[i].getAttribute('choosed')==null){\n                    liSection[i].remove();\n                }\n            }\n\n        }\n    }\n\n    search(word){        \n        this.searchedList = this.parser.search(word);\n        \n        if(this.searchedList[0]){\n            \n            //send list to props of the parent component \n            this.props.updateList(this.searchedList);\n\n            const sectionList = document.getElementsByClassName('search-control-info-list');\n            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n            \n              //console.log(searchedList)\n\n              this.searchedList.forEach(token =>{\n                var li = document.createElement('li');\n                li.className = 'search-control-info-list-item' \n                li.setAttribute('key', token.getId())     \n                li.innerHTML= `\n                    <spane>\n                        <img src=\"../../img/face.png\"/>\n                        <h3>${token.getFeature().properties.username}</h3>\n                        <h3>from ${token.getFeature().properties.city}</h3>                    \n                    </spane>\n                    <spane>\n                        <p>Skills: ${token.getFeature().properties.description}</p>                \n                    </spane> `\n\n                li.addEventListener(\"click\", this.clickListItem(this.props, this.parser, token));\n                li.addEventListener(\"click\", function(e){\n                    if (e.target && e.target.matches(\"li.search-control-info-list-item\")) {\n                        e.target.setAttribute(\"choosed\", \"true\"); // new attribute                        \n                      }\n                });\n\n                sectionList[0].appendChild(li);\n            })\n            \n        }\n    }\n\n\nrender() {\n\n    return (\n        <ul className=\"search-control-info-list\">                         \n        </ul>\n    );\n    }\n}\n","import React, {Component, useState} from 'react';\nimport SearchControlList from './SearchControlList'\nimport './search-control.css'\n\nexport default class SearchControl extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            isSearchVisible: false,\n            isCloseButtonVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: \"\"\n        };\n\n\n        //bind for callbacks\n        this.clickOpenSearchButton = this.clickOpenSearchButton.bind(this);\n        this.clickCloseButton = this.clickCloseButton.bind(this);\n        this.pressKeyInput = this.pressKeyInput.bind(this);      \n    }\n\n    clickOpenSearchButton() {\n        this.setState(state => ({\n            isSearchVisible: !state.isSearchVisible,\n            isWrapperList: \"closed\",\n            inputValue: \"\"        \n        }));\n\n        //send close to high component for update map view\n        this.props.closeSearch('closed');\n        //remove all children from search list\n        const sectionList = document.getElementsByClassName('search-control-info-list');            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n    }\n\n\n    clickCloseButton() {\n        this.setState(state => ({\n            isCloseButtonVisible: !state.isCloseButtonVisible,\n            isSearchVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: ''\n        }));\n\n        //send close to high component for update map view\n        this.props.closeSearch('closed');\n        //remove all children from search list\n        const sectionList = document.getElementsByClassName('search-control-info-list');            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n    }\n\n    pressKeyInput(event) {\n        \n        //visible close button \n        this.setState(state => ({\n            isCloseButtonVisible: true,\n            isWrapperList: \"opened\"\n        }));\n        //TODO: if(event.keyCode == 13)\n        \n    }\n\n    //it's call from SearchControlList to this parent component\n    updateList = (list) => {\n        \n        const newPersons = { \"type\": \"FeatureCollection\", \"features\": [] }  \n        list.forEach(token =>{\n            newPersons.features.push(token.getFeature())\n        })\n        \n        this.props.updateInfo(newPersons);\n\n\n    }\n\n    render() {\n      return (\n      <div className=\"search-box\">\n        <article className=\"search-control-wrap\">  \n            <section className={this.state.isSearchVisible?\"search-control search-control-active\":\"search-control\"}>\n                <button className=\"search-control-icon-button\" \n                    onClick={this.clickOpenSearchButton}>                \n                    <svg viewBox=\"0 0 50 50\">\n                        <line x1=\"35\" y1=\"35\" x2=\"46\" y2=\"46\"/>\n                        <circle cx=\"23\" cy=\"23\" r=\"16\" fill=\"none\"></circle> \n                            Sorry, your browser does not support inline SVG.\n                    </svg>                    \n                </button>                \n                <input \n                    type=\"text\" \n                    className=\"search-input search-control-input\" \n                    placeholder=\"custom placeholder\" \n                    onKeyDown={this.pressKeyInput}\n                    onChange={e => this.setState({ inputValue: e.target.value })} \n                    value={this.state.inputValue}/>                \n                <button className={ this.state.isCloseButtonVisible ? \"search-control-close-button search-control-close-button-active\": \"search-control-close-button\"} onClick={this.clickCloseButton}>\n                    <svg viewBox=\"0 0 50 50\">\n                        <path d=\"M5 5 L45 45 M45 5 L5 45\"/>\n                        Sorry, your browser does not support inline SVG.\n                    </svg>\n                </button>\n            </section>\n            <section className={this.state.isWrapperList==\"opened\"?\"search-control-info-wrapper\":\"search-control-info-wrapper search-control-info-wrapper-close\"} >\n                <section className=\"search-control-info\">            \n                    <SearchControlList \n\n                        activelist={this.state.isWrapperList} \n                        keys={this.state.inputValue}\n                        updateList = {this.updateList}\n                    />\n                </section>            \n            </section>    \n        </article>\n     </div>\n      );\n    }\n  }\n","'use strict'\n\nexport default class Utils {\n\n    constructor () {     \n        this.document = document\n    }\n\n    Subscribe(event, element, func) {\n        if (element.addEventListener) {\n            element.addEventListener(event, func, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, func);\n        } else {\n            element['on' + event] = func;\n        }\n      }\n    \n\n}\n\n\n","import React, { useEffect, useRef, useState} from 'react';\nimport L from 'leaflet';\nimport 'leaflet.markercluster'\nimport SearchControl from '../SearchControl/SearchControl';\nimport 'leaflet-boundary-canvas';\nimport Utils from '../Utils/Utilits';\nimport boundaries from \"../../data/boundaries.json\";\nimport persons from \"../../data/persons.json\";\n\n\nexport default function ContactMap(props) {\n\n  /**\n  * set new map and add boundared layer\n  */\n\n const boundariesColor = {\n    color: \"orange\",\n    fill: false \n  };\n\n  const center = [51.5167, 9.917];\n  const zoom = 6;\n  const latLngGeom = boundaries.geometry; //Define real geometry here\n  const osmUrl = 'https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png';\n  const osmAttribution = '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\n    \n\n  const mapRef = useRef(null)\n\n  useEffect(() => {\n\n    var osm = L.TileLayer.boundaryCanvas(osmUrl, {\n      boundary: latLngGeom,\n        attribution: osmAttribution\n    })\n    \n    mapRef.current = L.map('map', {\n        center: center,\n        zoom: zoom,\n        layers: osm\n    })\n        \n  }, [center, zoom])\n\n  /**\n   *  Set markers and position \n   */\n  \n  //set new icon image for markers\n  const activeIcon = L.icon({\n    iconUrl: './img/marker-icon.png',\n    iconSize: [25, 41],\n    iconAnchor: [12,41]\n  });\n\n\n  var ActivePeoples = L.geoJson(persons, {\n    pointToLayer: function (feature, latlng) {\n      \n      var marker = L.marker(latlng, {\n        icon: activeIcon\n      });\n\n      marker.bindPopup(\n        '<img src=\"../../img/face.png\"/>'+\n         '<br/>'+feature.properties.username + ' from '+feature.properties.city +        \n        '<br/>' + \"Skills: \" + feature.properties.description\n      );\n\n      //marker.openPopup() doesnt work in Safari\n      //this is some hook             \n      function func() {\n        marker.openPopup();\n      }        \n\n      var utils = new Utils();\n      utils.Subscribe('click', marker, func);        \n      return marker;\n    }\n\n  });\n\n\n  const boundariesLayer = L.geoJSON(boundaries, {\n    style: function (feature) {\n      return boundariesColor;\n    }\n  });\n\n\n  var clusters = L.markerClusterGroup();    \n    clusters.addLayer(boundariesLayer);\n    clusters.addLayer(ActivePeoples);\n\n  useEffect(() => {\n    \n    mapRef.current.addLayer(clusters)             \n\n  }, [clusters])\n\n\n\n/**\n * this is callback from SearchControlList component\n * @param list  returns the list of tokens to updating of our markers\n * @return new person.json object \n */\nfunction updateInfo(persons){   \n\n  clusters.removeLayer(ActivePeoples);\n\n  ActivePeoples = L.geoJson(persons, {\n    pointToLayer: function (feature, latlng) {      \n      var marker = L.marker(latlng, { icon: activeIcon});\n      marker.bindPopup(\n        '<img src=\"../../img/face.png\"/>'+\n         '<br/>'+feature.properties.username + ' from '+feature.properties.city +        \n        '<br/>' + \"Skills: \" + feature.properties.description\n      );\n      //marker.openPopup() doesnt work in Safari\n      //this is some hook             \n      function func() {\n        marker.openPopup();\n      }        \n      var utils = new Utils();\n      utils.Subscribe('click', marker, func);        \n      return marker;\n    }\n\n  });\n\n  clusters.addLayer(ActivePeoples);\n\n}\n\n/**\n * \n */\n\n function closeSearch(event){\n   if(event == 'closed'){    \n      updateInfo(persons);\n   }\n }\n\nreturn <div>\n          <SearchControl updateInfo={updateInfo} closeSearch={closeSearch}/>\n          <div id='map'></div>\n        </div>\n\n}","import React, { Component } from 'react';\nimport \"./App.css\";\nimport ContactMap from '../ContactMap/Contactmap';\n\n \nclass App extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div>\n        <ContactMap/>\n      </div>\n    );\n  }\n}\n \nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}