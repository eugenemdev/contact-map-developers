{"version":3,"sources":["components/Services/Grammar.js","components/Services/Token.js","components/Services/Lexer.js","components/Services/Parser.js","components/SearchControl/SearchControlList.js","components/SearchControl/SearchControl.js","components/Utils/Utilits.js","components/ContactMap/ContactMap.js","components/App/App.js","index.js"],"names":["Grammar","tokens","patterns","Token","this","token","type","value","id","position","start","line","column","end","feature","Lexer","stream","data","persons","grammar","features","forEach","createToken","checkTokens","properties","about","address","str","key","array","findMatches","setType","setValue","setPositionStartLine","setPositionStartColumn","String","length","setPositionEndLine","setPositionEndColumn","setId","setFeature","push","pattern","match","Parser","getStream","sortedStream","prepare","list","mapped","map","el","i","index","sort","a","b","getValue","result","word","patternWord","toLowerCase","isNaN","getType","uniq","getId","filter","item","pos","ary","SearchControlList","props","state","keys","activelist","parser","showList","search","setState","updateList","listItems","className","getFeature","name","username","company","Component","SearchControl","updateInfo","isSearchVisible","isCloseButtonVisible","isWrapperList","inputValue","clickOpenSearchButton","bind","clickCloseButton","pressKeyInput","event","onClick","viewBox","x1","y1","x2","y2","cx","cy","r","fill","placeholder","onKeyPress","onChange","e","target","d","Utils","document","element","func","addEventListener","attachEvent","ContactMap","ContactMapComponent","boundariesColor","color","useMap","latLngGeom","boundaries","geometry","activeIcon","L","TileLayer","boundaryCanvas","boundary","attribution","addTo","icon","iconUrl","iconSize","ActivePeoples","geoJson","pointToLayer","latlng","marker","bindPopup","age","description","Subscribe","openPopup","boundariesLayer","geoJSON","style","clusters","markerClusterGroup","addLayer","searchedMap","console","log","MapContainer","center","zoom","maxZoom","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.e538ff73.chunk.js","sourcesContent":["/**\n    Grammar is descriptions about tokens\n    @return patterns for search tokens and making tokens stream\n */\n\nconst Grammar = {    \n            tokens : {                \n                patterns: {\n                    \"javascript\": /[j|J](ava|)[s|S](cript|)/g,\n                    \"java\" : /[j|J](ava|AVA)(\\s)/g,\n                    \"c++\" : /[c|C](\\++|\\+|plus)/g,\n                    \"python\" : /[p|P](i|y|I|Y)(ton|thon|TON|THON)/g,\n                    \"php\" : /[p|P](h|H)(P|p)/g,\n                    \"swift\" : /[s|S](wift|WIFT)/g,\n                    \"android\" : /[a|A](ndroid|droid|NDROID|ndroid|nroid|NROID)/g,\n                    \"ios\" : /[i|I](OS|os|0s)/g,\n                    \"bash\" : /[b|B](ash|ASH)/g,\n                    \"text\" : /[a-zA-Z0-9_\\-\\+\\.\\:\\,\\!]+[\\w\\-\\+\\.\\:\\,\\!]/g                \n                }\n            }   \n        }\n\nexport default Grammar;","const Token = class Token {\n\n    constructor() {\n        this.token = {\n            type: \"\",\n            value: \"\",\n            id: \"\",\n            position: {\n                start: {\n                    line: \"\",\n                    column: \"\"\n                },\n                end: {\n                    line: \"\",\n                    column: \"\"\n                }\n            },            \n            feature: {}\n        }\n    }\n\n    setType(type) {\n        this.token.type = type;\n    }\n\n    getType() {\n        return this.token.type;\n    }\n\n    setValue(value) {\n        this.token.value = value;\n    }\n\n    getValue() {\n        return this.token.value\n    }\n\n    setId(id) {\n        this.token.id = id;\n    }\n\n    getId() {\n        return this.token.id\n    }\n\n    setPositionStartLine(line) {\n        this.token.position.start.line = line;\n    }\n\n    getPositionStartLine() {\n        return this.token.position.start.line\n    }\n\n    setPositionStartColumn(column) {\n        this.token.position.start.column = column;\n    }\n\n    getPositionStartColumn() {\n        return this.token.position.start.column;\n    }\n\n    setPositionEndLine(line) {\n        this.token.position.end.line = line;\n    }\n\n    getPositionEndLine() {\n        return this.token.position.end.line\n    }\n\n    setPositionEndColumn(column) {\n        this.token.position.end.column = column;\n    }\n\n    getPositionEndColumn() {\n        return this.token.position.end.column;\n    }\n\n    setFeature(feature){\n        this.token.feature = feature;\n    }\n\n    getFeature(){\n        return this.token.feature;\n    }\n\n}\n\nexport default Token;","import persons from '../../data/persons.json';\nimport grammar from './Grammar'\nimport Token from './Token'\n\n/**\n * Lexer's concept is:\n *   - token stream\n *   - token\n *   - lexical scoping\n *   - lexical context\n *   \n *   @param json file with information about developers\n *   @param Grammar.js with description of tokens      \n *   @return token stream\n *   \n *   @example:\n *       {\n *           type: 'text',\n *           value: 'this is the test',\n *           id: 12,\n *           position : {\n *              start: {\n *                  line: 0,\n *                  column: 1\n *              },\n *              end: {\n *                  line: 0,\n *                  column: 3\n *              }  \n *           },\n *           \"geometry\": {\n *              \"type\": \"Point\",\n *              \"coordinates\": [ \"7.705953\", \"52.358919\"]\n *            }   \n *        }\n *\n */\n\nconst Lexer =  class Lexer {\n\n    constructor(){\n        \n        this.stream = [];\n        this.data = persons;\n\n    }\n    \n    getStream(){\n\n        var patterns = grammar.tokens.patterns;\n\n        this.data.features.forEach(feature => {                    \n            \n            this.createToken(feature, 'name');\n            this.createToken(feature, 'username');\n            this.createToken(feature, 'company');\n            this.createToken(feature, 'age');       \n                 \n            this.checkTokens(feature.properties.about, feature);\n            this.checkTokens(feature.properties.address, feature);        \n            \n        })  \n\n        return this.stream\n    }\n\n    checkTokens(str, feature){\n        var patterns = grammar.tokens.patterns;\n        var line = 0;\n        var column = 0;\n\n        for(var key in patterns){            \n            const array = this.findMatches(str, patterns[key]);           \n            if(array!=null){\n                array.forEach(value => {\n                    \n                    var token = new Token();\n                    token.setType(key);\n                    token.setValue(value);\n                    token.setPositionStartLine(line);\n                    token.setPositionStartColumn(column);\n                    column = String(value).length;\n                    token.setPositionEndLine(line);\n                    token.setPositionEndColumn(column);\n                    token.setId(feature.id);\n                    token.setFeature(feature);\n                    this.stream.push(token);           \n\n                })\n            }\n            \n        }\n\n    }\n\n    createToken(feature, type){\n        \n        var line = 0;\n        var column = String(feature.properties[type]).length;\n        var token = new Token();\n\n        token.setType(type);\n        token.setValue(feature.properties[type]);\n        token.setPositionStartLine(line);\n        token.setPositionStartColumn(0);            \n        token.setPositionEndLine(line);\n        token.setPositionEndColumn(column);\n        token.setId(feature.id);\n        token.setFeature(feature);                     \n        \n        this.stream.push(token);           \n    }\n     \n    findMatches(str, pattern){        \n        return str.match(pattern)\n    }\n\n\n}\n\nexport default Lexer;","import Lexer from './Lexer'\n\n/**\n *  Syntax Tree is possible, but for first realisaton and quick search we need \n *  to use 'map' and function 'sort()' for abc-sorting \n *\n *  it will be in the future:\n *  Parses a stream of tokens into an Abstract Syntax Tree (AST)\n *  Concept: Absract Syntax Tree (AST), nodes , dynamic scoping, dynamic context\n *  Target: By nodes we can search more quickly and effecient. Nodes we can show as\n *          some filters in our html template\n *  \n *   {\n *      type: 'root',\n *      nodes: [\n *          {\n *          type: 'text',\n *          value: 'abc',\n *          position: {start: {column: 1 line: 1}, end: {column: 3, line: 1}}\n *          },\n *          {\n *          type: 'text',\n *          value: 'fde',\n *          position: {start: {column: 4 line: 1}, end: {column: 8, line: 1}}\n *          }, \n *          ...\n *      ]\n *   }\n * \n * \n */\n\nexport default class Parser {\n    constructor() {\n        this.stream = new Lexer().getStream();\n        this.sortedStream = [];\n        //make searched map\n        this.prepare();\n    }\n\n\n    prepare(){\n        // temp array consists of objects with position and sorting's value\n        var list = this.stream\n        var mapped = list.map(function (el, i) {\n            return {\n                index: i,\n                token: el\n            };\n        });\n\n        //sorting array\n        mapped.sort(function (a, b) {\n            if (a.token.getValue() > b.token.getValue()) {\n                return 1;\n            }\n            if (a.token.getValue() < b.token.getValue()) {\n                return -1;\n            }\n            return 0;\n        });\n\n        //result container\n        var result = mapped.map(function (token) {\n            return list[token.index];\n        });\n\n        this.sortedStream = result;\n        \n        return result\n    }\n\n    search(word) {\n        var list = this.sortedStream;\n        var result = []\n        var patternWord = word.toLowerCase();\n        //var pattern = \"/\" + patternWord + \"/\"\n\n        if (word.length >= 2) {\n\n            list.map(function (token) {\n\n                //number returns already undefined\n                // it will be checked as string or number\n                if (isNaN(token.getValue())) {\n\n                    var value = token.getValue();\n                    var type = token.getType();\n\n                    if (value.toLowerCase() == patternWord || type == patternWord) {\n\n                        result.push(token);\n\n                    }\n\n                } else {\n\n                    if (token.getValue() == patternWord) {\n\n                        result.push(token);\n\n                    }\n                }\n            })\n            \n\n            //remove double values and return \n            return this.uniq(result);\n        }\n\n        //if result []\n        return result;\n    }\n\n    findMatches(str, pattern) {\n        return str.match(pattern)\n    }\n\n    uniq(a) {\n        return a.sort(function (a, b) {                                \n            if (a.getId() > b.getId()) {\n                return 1;\n            }\n            if (a.getId() < b.getId()) {\n                return -1;\n            }\n            return 0;                \n        }).filter(function(item, pos, ary) {\n            //console.log(item.getId())\n            return !pos || item.getId() != ary[pos - 1].getId();\n        });\n    }\n\n}","import React, { Component }  from 'react';\nimport Parser from '../Services/Parser'\n\n\nexport default class SearchControlList extends Component {\n    \n    constructor(props) {\n        super(props);     \n        this.state = {\n            keys: \"\",\n            activelist: \"closed\"\n        };\n\n        this.parser = new Parser();\n        this.list = []; \n    }\n\n    componentDidUpdate(){\n        if(this.state.activelist != this.props.activelist){\n            this.showList();\n        }\n        \n        this.search(this.props.keys);\n    }\n\n    showList(){\n        this.setState({\n            activelist: this.props.activelist\n          });          \n    }\n\n    search(word){\n        this.list = this.parser.search(word);     \n        if(this.list[0]){\n            //send list tp props to the parent component\n        this.props.updateList(this.list);\n        }\n    }\n\n\nrender() {\n\n\n    var listItems = this.list.map((token) =>\n        \n    <li key={token.getId()} \n            className=\"search-control-info-list-item\">\n                Name: {token.getFeature().properties.name}\n                <br/>Username: {token.getFeature().properties.username}\n                <br/>Company: {token.getFeature().properties.company}\n                \n        </li>\n    );\n\n\n    return (\n        <ul className=\"search-control-info-list\">             \n            <li className=\"search-control-info-list-item\">\n                debug row| keys: {this.props.keys} |  visible: {this.props.activelist}\n            </li>            \n            {listItems}\n        </ul>\n    );\n    }\n}\n","import React, {Component} from 'react';\nimport SearchControlList from './SearchControlList'\nimport './search-control.css'\n\nexport default class SearchControl extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            isSearchVisible: false,\n            isCloseButtonVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: \"\"\n        };\n\n\n        //bind for callbacks\n        this.clickOpenSearchButton = this.clickOpenSearchButton.bind(this);\n        this.clickCloseButton = this.clickCloseButton.bind(this);\n        this.pressKeyInput = this.pressKeyInput.bind(this);      \n    }\n\n    clickOpenSearchButton() {\n        this.setState(state => ({\n            isSearchVisible: !state.isSearchVisible,\n            isWrapperList: \"closed\",\n            inputValue: \"\"        \n        }));\n    }\n\n\n    clickCloseButton() {\n        this.setState(state => ({\n            isCloseButtonVisible: !state.isCloseButtonVisible,\n            isSearchVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: ''\n        }));\n    }\n\n    pressKeyInput(event) {\n        \n        //visible close button \n        this.setState(state => ({\n            isCloseButtonVisible: true,\n            isWrapperList: \"opened\"\n        }));\n\n        //TODO: if(event.keyCode == 13)        \n    }\n\n    //it's call from SearchControlList to this parent component\n    updateList = (list) => {\n        this.props.updateInfo(list);\n      }\n\n    render() {\n      return (\n      <div className=\"search-box\">\n        <article className=\"search-control-wrap\">  \n            <section className={this.state.isSearchVisible?\"search-control search-control-active\":\"search-control\"}>\n                <button className=\"search-control-icon-button\" \n                    onClick={this.clickOpenSearchButton}>                \n                    <svg viewBox=\"0 0 50 50\">\n                        <line x1=\"35\" y1=\"35\" x2=\"46\" y2=\"46\"/>\n                        <circle cx=\"23\" cy=\"23\" r=\"16\" fill=\"none\"></circle> \n                            Sorry, your browser does not support inline SVG.\n                    </svg>                    \n                </button>                \n                <input \n                    type=\"text\" \n                    className=\"search-input search-control-input\" \n                    placeholder=\"custom placeholder\" \n                    onKeyPress={this.pressKeyInput}\n                    onChange={e => this.setState({ inputValue: e.target.value })} \n                    value={this.state.inputValue}/>                \n                <button className={ this.state.isCloseButtonVisible ? \"search-control-close-button search-control-close-button-active\": \"search-control-close-button\"} onClick={this.clickCloseButton}>\n                    <svg viewBox=\"0 0 50 50\">\n                        <path d=\"M5 5 L45 45 M45 5 L5 45\"/>\n                        Sorry, your browser does not support inline SVG.\n                    </svg>\n                </button>\n            </section>\n            <section className={this.state.isWrapperList==\"opened\"?\"search-control-info-wrapper\":\"search-control-info-wrapper search-control-info-wrapper-close\"} >\n                <section className=\"search-control-info\">            \n                    <SearchControlList \n\n                        activelist={this.state.isWrapperList} \n                        keys={this.state.inputValue}\n                        updateList = {this.updateList}\n                    />\n                </section>            \n            </section>    \n        </article>\n     </div>\n      );\n    }\n  }\n","'use strict'\n\nexport default class Utils {\n\n    constructor () {     \n        this.document = document\n    }\n\n    Subscribe(event, element, func) {\n        if (element.addEventListener) {\n            element.addEventListener(event, func, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, func);\n        } else {\n            element['on' + event] = func;\n        }\n      }\n    \n\n}\n\n\n","import React, { useEffect, useRef, useState} from 'react';\nimport L from 'leaflet';\nimport { MapContainer,  useMap} from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-markercluster';\nimport SearchControl from '../SearchControl/SearchControl';\nimport 'leaflet-boundary-canvas';\n\nimport Utils from '../Utils/Utilits';\nimport boundaries from \"../../data/boundaries.json\";\nimport persons from \"../../data/persons.json\";\n\nexport default function ContactMap(props) {\n\n  const center = [51.5167, 9.917];\n  const zoom = 6;\n\n  props = {\n    searchedMap: []\n  }\n    \n\n  function ContactMapComponent() {\n    \n    const boundariesColor = {\n      color: \"orange\",\n      fill: false \n    };\n    \n    var map = useMap()\n    //console.log('map center:', map.getCenter())\n  \n    var latLngGeom = boundaries.geometry; //Define real geometry here\n    var osmUrl = 'https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png';\n    var osmAttribution = '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\n  \n    var osm = L.TileLayer.boundaryCanvas(osmUrl, {\n      boundary: latLngGeom,\n      attribution: osmAttribution\n    }).addTo(map);\n  \n  \n    var activeIcon = L.icon({\n      iconUrl: './img/marker-icon.png',\n      iconSize: [25, 41]\n    });\n  \n    var inactiveIcon = L.icon({\n      iconUrl: './img/marker-icon-gray.png',\n      iconSize: [25, 41]\n    });\n  \n  \n    var ActivePeoples = L.geoJson(persons, {\n      pointToLayer: function (feature, latlng) {\n        // if (feature.isActive){\n  \n        var marker = L.marker(latlng, {\n          icon: activeIcon\n        });\n  \n        marker.bindPopup(\"Name: \" + feature.properties.name +\n          '<br/>' + \"Surname: \" + feature.properties.username +\n          '<br/>' + \"Age: \" + feature.properties.age +\n          '<br/>' + \"Company: \" + feature.properties.company +\n          '<br/>' + \"About: \" + feature.properties.about +\n          '<br/>'+\n          '<br/>' + feature.properties.description + ' '\n        );\n  \n        //marker.openPopup() doesnt work in Safari\n        //this is some hook             \n        function func() {\n          marker.openPopup();\n        }        \n  \n        var utils = new Utils();\n        utils.Subscribe('click', marker, func);        \n        return marker;\n      }\n  \n    });\n  \n    var boundariesLayer = L.geoJSON(boundaries, {\n      style: function (feature) {\n        return boundariesColor;\n      }\n    });\n  \n  \n    var clusters = L.markerClusterGroup();    \n    // clusters.addLayer(inactivePeoples);\n    clusters.addLayer(boundariesLayer);\n    clusters.addLayer(ActivePeoples);\n    map.addLayer(clusters);  \n   \n    return null\n  }\n    \n  function updateInfo(list){    \n      console.log(list)      \n      props.searchedMap =  list;\n  }\n\n  return (\n    <div>\n      <SearchControl updateInfo={updateInfo}/>\n      <MapContainer className=\"markercluster-map\" center={center} zoom={zoom} maxZoom={18}>\n        <ContactMapComponent/>         \n        <MarkerClusterGroup/>        \n      </MapContainer>\n    </div>\n    );\n  }","import React, { Component } from 'react';\nimport \"./App.css\";\nimport ContactMap from '../ContactMap/ContactMap';\n\n \nclass App extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div>\n        <ContactMap/>\n      </div>\n    );\n  }\n}\n \nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}